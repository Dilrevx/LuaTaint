"""This module contains vulnerability types, Enums, nodes and helpers."""

import json
from enum import Enum
from collections import namedtuple
import re
#from core.node_types import YieldNode


class VulnerabilityType(Enum):
    FALSE = 0
    SANITISED = 1
    TRUE = 2
    UNKNOWN = 3


def vuln_factory(vulnerability_type):
    if vulnerability_type == VulnerabilityType.UNKNOWN:
        return UnknownVulnerability
    elif vulnerability_type == VulnerabilityType.SANITISED:
        return SanitisedVulnerability
    else:
        return Vulnerability

def remove_escape_chars(lua_code):
    # Define a regular expression pattern to match unnecessary and incorrect escape characters
    pattern = r'(?<!\\)(?:\\\\)*\\(?![\nnrtfb\'"\\])'
    #pattern = r'(?<!\\)\\(?![\nnrtfb\'"\\])'
    '''To explain the regular expression pattern used in this function:
    (?<!\\) is a negative lookbehind assertion that matches any position that is not preceded by a backslash character.
    (?:\\\\)* is a non-capturing group that matches zero or more occurrences of two backslash characters (i.e. an escaped backslash).
    \\ matches a single backslash character.
    (?![nrt\'"\\]) is a negative lookahead assertion that matches any position that is not followed by one of the characters n, r, t, ', ", or \.'''
    # Use the re.sub() function to replace all matches of the pattern with an empty string
    cleaned_code = re.sub(pattern, '', lua_code)
    return cleaned_code
def fix_line(path, line_number):
        if os.path.isfile(path):
            with open(path, 'r',encoding='utf-8', errors = 'ignore') as f:
                txt = f.read()
                cleaned_code = remove_escape_chars(txt)
                def replace_render(match):
                    template_path = match.group(1)
                    parameters = match.group(2)
                    #print(template_path)
                    content=''
                    if os.path.isfile(os.path.join(project_root,"luci/view",template_path+'.htm')):
                        with open(os.path.join(project_root,"luci/view",template_path+'.htm'), 'r',encoding='utf-8', errors = 'ignore') as f:
                            txt = f.read()
                            pattern = r'<%:?=?\-?(?![#\+])(.*?)\-?%>'
                            matches = re.findall(pattern, txt, re.DOTALL)
                            for match in matches:
                                code_block = remove_escape_chars(match.strip())
                                params = re.findall(r'(\w+)\s*=\s*(\w+)', parameters)
                                for k,v in params:
                                    if k in code_block:
                                        code_block = code_block.replace(k,v)
                                content+=code_block+'\n'
                    #print(content)
                    return content
                if project_root:
                    pattern = r'luci\.template\.render\(\s*"(.*?)"\s*,\s*\{(.+?)\}\)'
                    cleaned_code_new = re.sub(pattern, replace_render, cleaned_code)
                    pattern = r'[Tt]emplate\("([^"]+)"\)'
                    matches = re.findall(pattern, cleaned_code_new)
                    #print("Extracted Strings:")
                    for match in matches:
                        if os.path.isfile(os.path.join(project_root,"luci/view",match+'.htm')):
                            with open(os.path.join(project_root,"luci/view",match+'.htm'), 'r',encoding='utf-8', errors = 'ignore') as f:
                                txt = f.read()
                                pattern = r'<%:?=?\-?(?![#\+])(.*?)\-?%>'
                                matches = re.findall(pattern, txt, re.DOTALL)
                                content='function '+match.replace('/','_')+'()\n'
                                for match in matches:
                                    code_block = remove_escape_chars(match.strip())
                                    #print(code_block)
                                    content+=code_block+'\n'
                                content+='end\n'
                                #print(content)
                                cleaned_code_new +=content
                    try:
                        #print(cleaned_code_new)
                        tree = ast.parse(cleaned_code_new)
                        return tree
                    except:
                        logging.error('The ast module can not parse the file after rendering')
def _get_reassignment_str(reassignment_nodes):
    reassignments = ''
    if reassignment_nodes:
        reassignments += '\nReassigned in:\n\t'
        reassignments += '\n\t'.join([
            'File: ' + node.path + '\n' +
            '\t > Line ' + str(node.line_number) + ': ' + node.label
            for node in reassignment_nodes
        ])
    return reassignments


class Vulnerability():
    def __init__(
        self,
        source,
        source_trigger_word,
        sink,
        sink_trigger_word,
        reassignment_nodes
    ):
        """Set source and sink information."""
        self.source = source
        self.source_trigger_word = source_trigger_word
        self.sink = sink
        self.sink_trigger_word = sink_trigger_word

        self.reassignment_nodes = reassignment_nodes
        '''self._remove_non_propagating_yields()

    def _remove_non_propagating_yields(self):
        """Remove yield with no variables e.g. `yield 123` and plain `yield` from vulnerability."""
        for node in list(self.reassignment_nodes):
            if isinstance(node, YieldNode) and len(node.right_hand_side_variables) == 1:
                self.reassignment_nodes.remove(node) '''

    def __str__(self):
        """Pretty printing of a vulnerability."""
        reassigned_str = _get_reassignment_str(self.reassignment_nodes)
        return (
            'File: {}\n'
            ' > User input at line {}, source "{}":\n'
            '\t {}{}\nFile: {}\n'
            ' > reaches line {}, sink "{}":\n'
            '\t{}'.format(
                self.source.path,
                self.source.line_number, self.source_trigger_word,
                self.source.label, reassigned_str, self.sink.path,
                self.sink.line_number, self.sink_trigger_word,
                self.sink.label
            )
        )

    def as_dict(self):
        return {
            'source': self.source.as_dict(),
            'source_trigger_word': self.source_trigger_word,
            'sink': self.sink.as_dict(),
            'sink_trigger_word': self.sink_trigger_word,
            'type': self.__class__.__name__,
            'reassignment_nodes': [node.as_dict() for node in self.reassignment_nodes]
        }


class SanitisedVulnerability(Vulnerability):
    def __init__(
        self,
        confident,
        sanitiser,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.confident = confident
        self.sanitiser = sanitiser

    def __str__(self):
        """Pretty printing of a vulnerability."""
        return (
            super().__str__() +
            '\nThis vulnerability is ' +
            ('' if self.confident else 'potentially ') +
            'sanitised by: ' +
            str(self.sanitiser)
        )

    def as_dict(self):
        output = super().as_dict()
        output['sanitiser'] = self.sanitiser.as_dict()
        output['confident'] = self.confident
        return output


class UnknownVulnerability(Vulnerability):
    def __init__(
        self,
        unknown_assignment,
        **kwargs
    ):
        super().__init__(**kwargs)
        self.unknown_assignment = unknown_assignment

    def as_dict(self):
        output = super().as_dict()
        output['unknown_assignment'] = self.unknown_assignment.as_dict()
        return output

    def __str__(self):
        """Pretty printing of a vulnerability."""
        return (
            super().__str__() +
            '\nThis vulnerability is unknown due to: ' +
            str(self.unknown_assignment)
        )


Sanitiser = namedtuple(
    'Sanitiser',
    (
        'trigger_word',
        'cfg_node'
    )
)


Triggers = namedtuple(
    'Triggers',
    (
        'sources',
        'sinks',
        'sanitiser_dict'
    )
)


class TriggerNode():
    def __init__(
        self,
        trigger,
        cfg_node,
        secondary_nodes=[]
    ):
        self.trigger = trigger
        self.cfg_node = cfg_node
        self.secondary_nodes = secondary_nodes

    @property
    def trigger_word(self):
        return self.trigger.trigger_word

    @property
    def sanitisers(self):
        return self.trigger.sanitisers if hasattr(self.trigger, 'sanitisers') else []

    def append(self, cfg_node):
        if not cfg_node == self.cfg_node:
            if self.secondary_nodes and cfg_node not in self.secondary_nodes:
                self.secondary_nodes.append(cfg_node)
            elif not self.secondary_nodes:
                self.secondary_nodes = [cfg_node]

    def __repr__(self):
        output = 'TriggerNode('

        if self.trigger_word:
            output = '{} trigger_word is {}, '.format(
                output,
                self.trigger_word
            )

        return (
            output +
            'sanitisers are {}, '.format(self.sanitisers) +
            'cfg_node is {})\n'.format(self.cfg_node)
        )


def get_vulnerabilities_not_in_baseline(
    vulnerabilities,
    baseline_file
):
    baseline = json.load(open(baseline_file))
    output = list()
    for vuln in vulnerabilities:
        if vuln.as_dict() not in baseline['vulnerabilities']:
            output.append(vuln)
    return(output)


def filter_non_external_inputs(vulnerabilities):
    pattern = 'luci/controller'
    for vul in range(len(vulnerabilities)-1,-1,-1):
        if (not pattern in vulnerabilities[vul].sink.path) and (vulnerabilities[vul].source_trigger_word == 'Framework function URL parameter'):
            vulnerabilities.remove(vulnerabilities[vul])
    return(vulnerabilities)